
SQL conspect
------------------------------------------------------------------
01_IntroToDatabasesSQLQueries

 DB -Intro to Databases, SQL Queries
 


SQL мова структурованих запитів (Structured Query Language) - це декларативна мова програмування, яка використовується для управління та роботи з даними в реляційних базах даних. Вона дозволяє створювати, змінювати, видаляти та отримувати дані з баз даних


СУБД - система управління баз данних


реляційна БД - БД яка зберігає звязані об'єкти


SQL - вся інформація представлена у таблицях


				типи даних
Назва				Діапазон					Пам'ять

bigint		ВІД -9 223 372 036 854 775 808		8 байт
			до 9 223 372 036 854 775 807
			
int			ВІД -2 147 483 648 ДО 2 147 483 647  4 байта
smallint	ВІД -32 768 до 32 767				 2 байта
tinyint		ВІД 0 до 255						 1 байт

bit 		ВІД 0 ДО 1	TRUE/FALSE						


money		від -922 337 203 685 477,5808		8 байт
			до 922 337 203 685 477,5807	
			
smallmoney	ВІД -214 748,3648 до 214 748,3647	4 байта		Тип для зберігання менш точних валютних сум, має менший діапазон, ніж money.

float(double)	-1.79E+308 до 1.79E+308 (приблизно)	8 байт		Тип для зберігання чисел з плаваючою комою великої точності, використовується для наукових обчислень.

real(float)		-3.40E+38 до 3.40E+38 (приблизно)	4 байта		Тип для зберігання чисел з плаваючою комою, але менш точний, ніж float.

char	Фіксована кількість символів (1-8000 символів)	1 байт на символ	Тип для зберігання рядків фіксованої довжини. Якщо рядок коротший за визначену довжину, решта символів заповнюється пробілами.

nvarchar	0 до 4 000 символів (потрібно більше для Unicode символів)	2 байта на символ	Тип для зберігання рядків змінної довжини, який підтримує Unicode символи (забезпечує підтримку різних мов і символів).

---

char(n)		- без кодування Unicode фіксованої довжини
varchar(n|max)	- без кодування Unicode змінної довжини


nchar(n)		- З кодуванням Unicode фіксованої довжини
nvarchar(n|max)	- З кодуванням Unicode змінної довжини

------------------------------------------------------------------
02_SQLCommands

 DB - SQL Commands


---SQL commands---

 DDL - data defenition language
 
	create   - створює новий об'єкт		 
	alter    - міняє існуючий об'єкт У ТАБЛИЦІ			 
	drop     - видаляє без онулення інформації		 
	rename   - переіменовує
	truncate - видаляє з онуленням

	comment  - 

 DML - data modeling language

	select - вибір таблиці 
	insert - додає новий запис в таблицю		  
	update - оновити значення У КОМІРЦІ		   
	delete - видаляє 1 рядок

	merge  - об'єднати	
	call   -	
	expain plan	
	lock table
	
 DCL - для адміністрування

	Grant -	
	Revoke -

 TCL - транзакції

	commit	
	rollback	
	savepoint
	set transaction
	
	
---SQL commands---

 виділяємо рядок а потім execute щоб його виконати

 primary key - ключ унікальний неповторний

--	коментар	| 	/* */  багаторядковий коментар

create DAtAbase University_PD411	/створить БД не зважаючи на регістр


 drop  University_PD411 	//delete  University_PD411
 
 use  University_PD411		//вибрати  University_PD411


/*
constraint1 constraint2 constraint3.....
	1. Column parameters
		- NULL(default)	| NOT NULL
		- Unique
		- primary key (unique)
		- Identity(start,step)	identity(1,1) - default //автозбільшення
		- default(value)
		- check(condition)
		logic operator : >  <  >=  <=  <>(!=) ==  !<  !>
		logic i(&&)	: and
		logic or (||): or
*/

create table Students(
	
	--name type constraint1 constraint2 constraint3....
		
			(містить NOT NULL unique)
	Id int primary key identity,		//створ ключ Id який унікальний і не null
	
	Name nvarchar(50) not null 			check(Name <>''),
	Lastname nvarchar(50) not null 		check(Lastame <>''),
	Surname nvarchar(50) not null 		check(Surname <>''),
	
										/DateTime.Now
	Birthday date not null check(Birthday < GETDATE()),
	
	Phone char(13) not null,	//13 символів обовязково	
	Adress nvarchar(50) null,	
	
						/AverageMark >= 1 and AverageMark <= 12
	AverageMark float not null check(AverageMark between 1 and 12),
	
	IsDebtor bit not null default(0),
	Lessons int not null check(Lessons >= 0),
	
	Fails int not null check(Fails >= 0),	//Fails < Lessons - помилка
	
	Visiting as Lessons - Fails
	
	--level statment	(бачить усі колонки)
	check( Fails < Lessons)
);

select * from Students

--Заповнюємо таблицю значеннями--	

insert into Students

		name   Lastname		surname		birthday	phone		adress	avg   debt  lesons fails
values('Oleg','Petrovich','Oliunuk','1990-12-15','+380987654321','Rivne',7.9,default,150,15),
('Petro','Petrovich','Oliunuk','2006-12-15','+380933354321','Rivne',10.9,default,100,15),
('Ivan','Petrovich','Oliunuk','1998-12-15','+380987668327','Rivne',9.9,1,120,15)


------------------------------------------------------------------
03_SQLQueryCommandsSelectInsertUpdateDelete

 DB - SQL. Query Commands. SELECT, INSERT, UPDATE, DELETE Запити

 alter  - міняє існуючий об'єкт У ТАБЛИЦІ	

		-ALTER-
	
alter table Students	
	//пропис всі остальні constraint що були
alter column Name nvarchar(100) not null


	alter table Students
--alter DegreeDate date not null	//помилка бо неможе записати null черз constraint

alter DegreeDate date not null default(getdate())   //рішення


	//not null -> null | можна alter column Name nvarchar(100) NULL
	
	//null -> not null | не можна


		-EXECUTE-

		/rename			з 				на
execute sp_rename 'Students.Phone', 'PhoneNumber', 'COLUMN'


		-SELECT-	/показує

/*
select що саме
from звідки
додат параметри (фільтрації, сортування, групування)

select column1, column2
from table1
where умова - фільтрації
order by ключ - сортування

*/

select * from Students

select Name, Surname, AverageMark
from Students

select Name, Surname, AverageMark, DegreeDate
from Students


		//1 колонка		//2 колонка
select [Name] + ' ' + Surname, AverageMark *10	//[] означ наш елемент
from Students

		//as виводть назву колонки зверху
		//as [ Mark ] - вказ назву для колонки
select [Name] + ' ' + Surname as 'Full Name', 
						AverageMark *10 as [Mark]
from Students

				//Чистий SQL
			//CAST перетвор з float на nvarchar
 select 'Student' + Surname + ' has ' 
 			+ CAST(AverageMark as nvarchar(10)) as 'Full info'
 from Students

		
				//T-SQL
select 'Student' + Surname + ' has ' 
			+ CONVERT(nvarchar(10), AverageMark) as [Full info]
from Students


		-TOP-		/бере перші по списку
		
	//перші 3 записи	
select TOP(3) [Name] + ' ' + Surname as FullName, 
		AverageMark *10 as[Average Mark] 	
from Student		
		
		
	//перші ПОЛОВИНА записів
select TOP 50 PERCENT [Name] + ' ' + Surname as FullName, 
		AverageMark *10 as[Average Mark] 	
from Student		
		
		
		-Distinct-		/урізає дублікати
		
select Distinct Name,Surname
from Students		
		
		
		-Where-		/Фільтрує по заданій умові
		
		logic operator : >  <  >=  <=  <>(!=) =(C# ==)  !<  !>
		logic i(&&)	: and
		logic or (||): or
	
select *
from Students		//показ всіх у кого AverageMark >= 10
where AverageMark >= 10	

where Name <>'Oleg'	// всі хто не Oleg


		=Функції для отримання дати=	

	DAY(date) - повертає день з дати
	MONTH(date) - повертає місяць з дати
	YEAR(date)  - повертає рік з дати

select *
from Students		//показ День народження Літом
where Month(Birthday) between 6 and 8

where YEAR(Birthday) = 2000 or YEAR(birthday) = 1999
	//or
where YEAR(Birthday) in (2000,1999)


		=Where Name LIKE 'pattern'=

[value] LIKE 'pattern' - перевіряє значення [value] на відповідність 
							шаблону

	% будь-яка кількість символів
	
	_ будь-який один символ
	
	[] будь-який символ, який наявний в дужках
	
	[^] будь-який символ, який НЕ наявний в дужках


	-Order By -

Select * from Students
where AverageMark in (11,8.5,9)
order by AverageMark desc	 //asc(default)

order by Surname, Name


------------------------------------------------------------------
04_RelationsForeignKeys

 Type of relations:
	- zero or one to many 0/1...*
	- one to one 	1...1
	- one to many 	1...*		//самий поширений
	- many to many	*...*
	
	
Звязки створ по Id

Create table Groups(
	Id int primary key identity,
	Name nvarchar(50) not null check (Name <>') unique,
	StartDate date not null default (GETDATE())
)

create table Students(
	Id int primary key identity,
	Name nvarchar(50) not null check (Name <>**),
	Lastname nvarchar(50) not null check(Lastname <>''),
	Birthdate date not null check (Birthdate < GETDATE()),
	Phone char(13) not null,
	Email nvarchar(50) null,
	AverageMark float not null check (AverageMark between 1 and 12),
	Lessons int not null check (Lessons >= 0),
	
	--References	- foreign key (зовнішній ключ)
		//one to many
		
	GroupId int not null references Groups(Id)	//1....20
	
);	
	
	
	create table Teachers
(
    Id int primary key identity,
	Name nvarchar(50) not null check(Name <>''),
	Lastname nvarchar(50) not null check(Lastname <>''),
	HireDate date not null,
	Phone nvarchar(20) not null
);
		
	
	create table TeachersGroups			//проміжна таблиця
(
	TeacherId int not null references Teachers (Id), -- 1 1 1 2 7 2 5	1..20
	GroupId int not null references Groups (Id),	 -- 4 3 5 4 4 3 4 	1...20
	
	-- складений первинний ключ
	primary key (TeacherId, GroupId)	//перевіряє комбінації на дублікат
)
	
	
	
Many To Many | створ проміжну таблицю з двох

One To Many  | НАЗВАid references НАЗВА(Id)

	//One to Many

DepartmentId int not null references Departments(ID)

//or

alter table Wards
add foreign key (DepartmentId) references Departments(ID)



	select Students.Name, Students.Lastname, Students.AverageMark,  Groups.Name, Groups.StartDate
	from Students, Groups
	where Students.GroupId = Groups.Id
	
	select s.Name, s.Lastname, s.AverageMark,  g.Name, g.StartDate
	from Students as s, Groups as g
	where s.GroupId = g.Id and s.AverageMark >= 10

	
------------------------------------------------------------------
05_ JoinOperators

Type of relations:
	- zero or one to many 0/1...*
	- one to one 	1...1
	- one to many 	1...*	
	- many to many	*...*


create table Countries(
	Name nvarchar(50) not null check (Name <>'')
	Id int primary key identity,
)


alter table Students
add CountryId int null references Countries(Id)


update Students
set CountryId = 1

where Id in(1,5,7,9)




select s.Name, s.Lastname, s.AverageMark, g.Name, g.StartDate
from Students as s, Groups as g
where s.GroupId = g.Id and s.AverageMark >= 10	
order by s.AverageMark desc

//або

select s.Name, s.Lastname, s.AverageMark, g.Name, g.StartDate
from Students as s JOIN Groups as g on s.GroupId = g.ID
where s.AverageMark >= 10	//фільтрує 
order by s.AverageMark desc


select s.Name, s.Lastname, s.AverageMark s.GroupId 

from Students as s JOIN Group as g ON s.GroupId = g.Id
where g.Name = 'Група 5'


JOIN - з'єднує 2 таблиці між собою але після on вказ ключі 
			через які їх з'єднуємо (первинний = зовнішній)

Teacher as t JOIN TeacherGroups as tg on t.id = tg.TeacherId


------------------------------------------------------------------
06_ AggregationGrouping

 update - змінити insert


 Функція		Опис
 
 COUNT(*)		Підраховує кількість рядків		| з усіма типами данних
 COUNT(column)	Підраховує кількість НЕ NULL значень у колонці
 SUM(column)	Обчислює суму значень
 AVG(column)	Обчислює середнє значення
 MIN(column)	Знаходить мінімальне значення	| з усіма типами данних
 MAX(column)	Знаходить максимальне значення	| з усіма типами данних


Агрегаційні функції на основі багатьох записів повертають одне значення
					ніколи не повертають колекцію

 select COUNT(Id) [Number of Students]
from Students


 select Max(Name) as [Max Name]
from Students

 select AVG(AverageMark) as [AverageMark]
from Students
where YEAR(Birthdate) > 2000

	неможна виводити колонки з агрег функціями
 select COUNT(s.Id), AVG(s.AverageMark) і g.Name

--
	ROUND() rounds a number to a specified number of decimal places.
	
	FLOOR() returns the largest integer value that is smaller than or equal to a number.
	
	CEILING() returns the smallest integer value that is larger than or equal to a number.


 select COUNT(s.Id) as 'Count Students',
  ROUND(AVG(s.AverageMark),2) as 'Average Mark',	//вивод 2 цифри після коми
 Sum(s.Lessons) as 'Count lessons'
 from Students as s JOIN Groups as g on s.GroupId = g.Id
 where g.Name = 'Група 6'

--

	GROUP BY — групує рядки з однаковими значеннями в одну групу, після чого можна застосовувати агрегатні функції до кожної групи.

  select *		//помилка
  from Students
  group by AverageMark

	при групуванні у
select вказ ключ групування або агрегаційна функція

		 ключ			агрег функція для кожної групи працює окремо
 select AverageMark, COUNT(Id)
 from Students
 group by AverageMark


коли робимо групування може вказати тільки ключ групування
			або агрег функцію

 group by використовується щоб вивести значення і агрег функцію
				назва групи - кількість студентів


	select AverageMark, 
			COUNT(Id) as 'Student Count',
			MIN(BirthDate) as 'Oldest Student'
	from Students
	where AverageMark >= 9
	group by AverageMark
	order by MIN(BirthDate) -- 'Oldest Student'


   where - фільтрація початкова | перед group by

  having - фільтрує згруповані данні | після group by

	-- так як оператор WHERE виконується ще до групування, то профільтрувати групи там неможливо
	-- для цього використовуємо оператор HAVING після GROUP BY

------------------------------------------------------------------
07_ SQLSubqueries

	підзапит

select
from Wards
where Places (select MIN(Places) from Wards)


	declare - створ змінну


 declare @min_mark float = (select MIN(Places) from Wards);
 
 print @min_mark

		//отимізованіший 
select
from Students
where AverageMark = @min_mark

 ------показати всіх студентів, які навчаються в групі, де 5 і більше людей---

select *				//не вийде помістити підзапит у змінну бо GroupId ЗМІНЮЄТЬСЯ
from Students as s		
where (select COUNT(Id)		//Students as s 	І	 s.GroupId 	дозволяють змінювати GroupId
		from Students
		where GroupId = s.GroupId) >= 5

/*
select COUNT(Id)		//проходить по студентам у яких група під ІД 5
	from Students
	where GroupId = 5
	
		*/


-------

UNION - об'єднує декілька запитів в одну результуючу таблицю
	   при цьому видаляючи дублікати


union - урізає дублікати складає 2 таблиці в 1

union all - показує абсолютно все з 2х таблиць


кластеризована індексація - коли данні складаються в БД 
			для кожного елемента дається індекс, по якому вони складаються

------------------------------------------------------------------
08_ViewsTableCommands

 
 VIEW (представлення) це об'єкт БД, який має зовнішній
 вид таблиці, але на відміну від неї не має своїх власних даних.
 Представлення лише надає доступ до даних однієї або декількох таблиць, на яких воно базується

всередині view не можна робити order by
дозволяється лише з TOP

як функція  print
нічог не приймає не повертає


 для view можна вказати деякі параметри:
--		encryption		- view буде зберігатися в зашифрованому вигляді | не змінний через редактор
--		schemabinding	- забороняє видалення таблиць, представлень та функцій які використовує дане view
--		view_metadata	- вказує на те, що view в режимі перегляду буде повертати його метадані,
--						  тобто інформацію про його структуру, а не записи таблиць


- ORDER BY дозволяється всередині view лише разом з оператором TOP 


 create view Top3GoodStudents (Name, Email, Mark)
as
	select top 3 Name, Email, AverageMark
	from Students
	where AverageMark >= 9
	order by AverageMark DESC


-- До представлення можна застосовувати DML команди: INSERT, UPDATE, DELETE

insert into GoodStudents	//не безпечно можна додати будь-кого в Students через view GoodStudents
values ('Inna', 'Oliunuk', 'inna@gmail.com',3.7);


	UPDATEABLE VIEW (оновлююче представлення)
	
 create or alter view GoodStudentsWithCheck
as
	select Name, Lastname, Email, AverageMark
	from Students
	where AverageMark >= 7
	with check option; -- забороняє модифікувати записи (INSERT, UPDATE, DELETE) для записів, які не 
												підлягають результату VIEW 


 insert into GoodStudentsWithCheck		//добре
values ('Olga', 'Amirov', 'olia@gmail.com', 12);

insert into GoodStudentsWithCheck		//помилка
values ('Bob', 'hsjhsdkjg', 'OLGA123@gmail.com',3.7);



--declare @@global_var int = 333;
--declare @number int = 10;

 select @number as 'Local', @@global_var as 'Global'


 =raiserror=
											//ступінь  //state(Id помилки)
raiserror('Something went wrong! File: %s, Id: %d', 15, 1, 'main_bd.md', 34);

declare @number INT = 777;
RAISERROR ('Number: %d %s', 11, 1, @number, 'value')
-- Severity: 1-10 - warnings (not errors)
--			11-15 - user errors
--			16-24 - system errors (18 > fatal error)
-- %d, %i - digit
-- %s - string
-- %u - unsigned digit

select * from sys.messages
where message_id = 29300

raiserror (29300, 16, 1, 'windows.exe');


------------------------------------------------------------------
09_T-SQLStorageProcedures

procedure - як функція
 
 create procedure ShowHello
 as	
 begin	//як {
 	print 'Hello world'
 	print 'Hello world'
 	print 'Hello world'
 	
 end	//як }
 
 execute ShowHello


 Скалярна функція - повертає 1 значення


declare робить зміння поки скрипт виділений

	процедура з параметром
	
 -- with params
create proc sp_students_list 
@mark int
as
	select * from Students
	where AverageMark >= @mark

exec sp_students_list 10


 ref - прац з оригіналом змінна повинна бути ініціалізована
 out - прац з оригіналом змінна може бути не ініціалізована